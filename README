Rebase is a Divergence module that provides operator overloading and syntactic macros. For example:

  (function (x) {return x << 4}) ([1, 2, 3])            // Nothing useful

To add an operator, you just set a member of the prototype:

  Array.prototype['<<'] = function () {this.push.apply (this, arguments); return this};
  d.rebase (function (x) {return x << 4}) ([1, 2, 3])   // => [1, 2, 3, 4]

You can also create new operators using 'sandwich identifiers', which are identifiers that, when placed
between two binary operators, will become part of those operators. For example:

  d.rebase.sandwiches['foo'] = true;
  d.rebase (function (x) {return x >foo> y})    // => x['>foo>'](y)

You can overload these operators in exactly the same way.

Caveats:

  1. Method calls are a lot slower than operators, so Rebase will slow your code down by quite a bit.
  2. Using Rebase without overloading the right operators will cause lots of stuff to break! I haven't
     yet written the compatibility interfacing required to fill in behavior for the predefined operators.
  3. All of your postfix ++ and -- operators will be converted to prefix. This is totally a bug!
  4. Statement-mode function definitions aren't allowed -- you have to use var f = function () ...
     instead of function f () ...

Syntactic macros.
Rebase also lets you transform the syntax tree in arbitrary ways. Any function in the d.rebase.macros
array will be run on each syntax node. This lets you do a number of useful things, including inserting
debugging information, tracing things, or coming up with new meanings for existing operators.

The value passed into a macro will have one of three types:

  1. A syntax tree node
  2. A string representing some token of input
  3. undefined, meaning that there isn't anything there

Syntax tree nodes each have a parent, an operator (whose arity, precedence, etc. can be checked by
the functions and hashes inside d.rebase), and an array of operands called xs. Note that the syntax
tree constructed by Rebase is not complete or necessarily even correct; its only purpose is to provide
some minor degree of abstraction above a string.

Tokens are represented exactly as typed. This includes nullary keywords such as break and continue,
strings, regular expressions, numbers, booleans, etc.

Undefined is encountered in situations where the JavaScript grammar isn't really expression-oriented.
This includes statement processing -- for example, if you type ;;; in a function, then there are two
empty statements. Those statements must exist in some form in an expression-oriented parse tree, but
they don't actually get rendered into the output. So the values representing those statements would be
undefined.
