Rebase is a Divergence module that provides operator overloading and syntactic macros. For example:

  (function (x) {return x << 4}) ([1, 2, 3])            // Nothing useful

To add an operator, you just set a member of the prototype:

  Array.prototype['<<'] = function () {this.push.apply (this, arguments); return this};
  d.rebase (function (x) {return x << 4}) ([1, 2, 3])   // => [1, 2, 3, 4]

You can also create new operators using 'sandwich identifiers', which are identifiers that, when placed
between two binary operators, will become part of those operators. For example:

  d.rebase.sandwiches['foo'] = true;
  d.rebase (function (x) {return x >foo> y})    // => x['>foo>'](y)

You can overload these operators in exactly the same way.

You can also rebase expressions, just like eval:

  d.rebase ('[1, 2, 3] << 4')   // => [1, 2, 3, 4]

However, these expressions don't close over surrounding variables. The best way to achieve that is to
preload a function:

  d.rebase (function (x, y, z) { ... x y z ... }).fn (x, y, z);

Note that you can't say it this way:

  d.rebase ((function (x, y, z) { ... }).fn (x, y, z))

because then you'd be rebasing the proxy function that fn() creates. Instead, you have to rebase the
original and proxy the result with the preloaded arguments. (See the Divergence documentation if this
usage of fn() seems unfamiliar.)

Caveats:

  1. Method calls are a lot slower than operators, so Rebase will slow your code down by quite a bit.
  2. All of your postfix ++ and -- operators will be converted to prefix. This is totally a bug!
  3. Statement-mode function definitions aren't allowed -- you have to use var f = function () ...
     instead of function f () ...
  4. Rebased functions aren't closures. They're re-evaluated at the global scope, which means that any
     closed-over variables will have to be passed in explicitly. However, all sub-functions inside a
     rebased function will close over variables within the rebased function's scope.
  5. SpiderMonkey JS does aggressive constant-folding, including replacing certain arithmetic expressions
     with NaN if it can determine that the types won't work out. In particular, this includes bit-shifting
     by a string literal, for instance. So for reliable operation, you should use variables instead of
     literals to avoid these issues.

Rebase uses a series of functions installed on the prototypes of all standard types in order to mimic
the default behavior. However, these functions will often have bugs; for example, boolean && and || will
behave incorrectly since the /this/ reference is boxed and thus never false.

Syntactic macros.
Rebase also lets you transform the syntax tree in arbitrary ways. Any function in the d.rebase.macros
array will be run on each syntax node. This lets you do a number of useful things, including inserting
debugging information, tracing things, or coming up with new meanings for existing operators.

The value passed into a macro will have one of three types:

  1. A syntax tree node
  2. A string representing some token of input
  3. undefined, meaning that there isn't anything there

Syntax tree nodes each have a parent, an operator (whose arity, precedence, etc. can be checked by
the functions and hashes inside d.rebase), and an array of operands called xs. Note that the syntax
tree constructed by Rebase is not complete or necessarily even correct; its only purpose is to provide
some minor degree of abstraction above a string.

Tokens are represented exactly as typed. This includes nullary keywords such as break and continue,
strings, regular expressions, numbers, booleans, etc.

Undefined is encountered in situations where the JavaScript grammar isn't really expression-oriented.
This includes statement processing -- for example, if you type ;;; in a function, then there are two
empty statements. Those statements must exist in some form in an expression-oriented parse tree, but
they don't actually get rendered into the output. So the values representing those statements would be
undefined.
